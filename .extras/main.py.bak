# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# MAIN PYTHON FILE (main.py)
# # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# GENERAL NOTES:
# - YELLOW refers to PLAYER_MAX's spaces (and the placeholders are 1)
# - RED refers to PLAYER_MIN's spaces (placeholders for: -1)
# - The x value (m[x]) in board.matrix is the column

# IMPORTS
# Interpreter
from interpreters.terminal import displayBoard

# Necessary imports below
from constants import *
from board import Board
import json

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# MINIMAX algorithm
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Statistics
stat_cycles = 0

# MINIMAX CACHE: A storage system to save computation
# ===============================================================================
def boardToStr(board):
    return json.dumps(board.matrix, separators=(",", ":"))

# Cache => Entry: board, value
doCache = True
doCacheExport = False
cache = {}
cache["board"] = []
cache["value"] = []

def cacheExport():
    if doCacheExport:
        with open("./cache.json", "w") as file:
            file.write(json.dumps(cache, separators=(",", ":")))

def cacheImport():
    global cache
    with open("./cache.json", "r+") as file:
        cache = json.loads(file.read())



# MINIMAX: gets the game state of the board inputted by examining all possible outcomes
# ===============================================================================
def minimax(board, lastMove=None, depth=1):
    # Check cache for output
    if doCache:
        boardStr = boardToStr(board)
        if boardStr in cache["board"]:
            return cache["value"][cache["board"].index(boardStr)]

    # Update statistics
    global stat_cycles
    stat_cycles = stat_cycles + 1

    # Set necessary varaibles
    # Set player and move choosing function
    player = board.getTurn()
    minOrMax = max if player == PLAYER_MAX else min

    # Check if the board is at a terminal status (game over)
    # Get the state
    state = board.getTerminalGameState()
    # If game over
    if state != None:
        return state

    # Get all possible moves
    moves = board.getMoves()

    # Get move values for every possible move
    moveValues = []
    for moveXY in moves:
        # Create a new board and make that move in it
        nb = board.clone()
        nb.makeMove(moveXY, nb.getTurn())

        # Do statistical prints
        print(stat_cycles, depth)
        # displayBoard(nb, end="")

        # If the depth isn't at 0:
        #   Run this function again on the new board with +1 depth
        if depth != 0:
            # Run minimax function
            moveValues.append(minimax(nb, depth=depth+1, lastMove=moveXY))
        else:
            # Do predictive algorithm (none)
            moveValues.append(0)
    
    # Choose what move value is optimal
    output = minOrMax(moveValues)
    # Handle output
    if doCache:
        cache["board"].append(boardToStr(board))
        cache["value"].append(output)
    return output




# GET BEST MOVE: Similar to minimax, but just gets the values of all possible moves and
#   returns the coordinates of the best one
# ===============================================================================
def getBestMove(board, depth=1):
    # Get the players turn
    player = board.getTurn()

    # Get all possible moves
    moves = board.getMoves()

    # Get move values for every possible move
    moveValues = []
    for moveXY in moves:
        # Create a new board and make that move in it
        nb = board.clone()
        nb.makeMove(moveXY, nb.getTurn())
        # Get the value of that move
        moveValues.append(minimax(nb, depth=depth))
    
    if player == PLAYER_MAX:
        return moves[moveValues.index(max(moveValues))]
    elif player == PLAYER_MIN:
        return moves[moveValues.index(min(moveValues))]
        

# MAIN CODE
# ==========================
b = Board()
cacheImport()

# Note: this board looks flipped on its side
# b.matrix=[
#     [ 1, -1,  1, -1,  1, -1],
#     [ 1, -1,  1, -1,  1, -1],
#     [-1,  1, -1,  1, -1,  1],
#     [ 0,  0,  0, -1, -1,  1],
#     [ 0,  0,  0,  0,  1,  1],
#     [ 1, -1,  1, -1,  1, -1],
#     [-1,  1, -1,  1, -1,  1]
# ]

try:
    while not b.isTerminal():
        b.makeMove(getBestMove(b), b.getTurn())
        print("Final: "+str(b.getTurn())+"'s turn", stat_cycles)
        displayBoard(b)
        input()
except:
    if input("Save Cache to 'cache.json'? (y/n)") == "y":
        cacheExport()

cacheExport()